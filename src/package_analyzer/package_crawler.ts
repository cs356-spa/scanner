import * as fs from "fs";
import * as path from 'path';
import * as util from "util";
import { Cluster } from 'puppeteer-cluster';
import { collectNotableStrings, PackageStringsByVersionMapWithInfo, testStringsOnBundleStrings } from './packageUtils';
import { parseCSV } from "../top-sites";

const debug = require("debug")("pkg");

// FOR DEBUGGING: If set to true, will display match counts of different package versions if we decide the package is found.
const DISPLAY_MATCH_VERSION_STATS = false;
// FOR DEBUGGING: check the actual jquery versions, a good example to evaluate if our detection is good enough.
const DISPLAY_REAL_JQUERY_VERSION_IF_PRESENT = false;
const JQUERY_DEBUG_STATS = {};
// Minimum strings to appear in a file such that we consider a package of a certain version is found.
const MIN_MATCH_STRING_COUNT = 3;

const sleep = (ms: number) => new Promise(res => setTimeout(res, ms));

/**
 * Print fully the object details, don't stop after some level of nesting.
 * @param v thing to inspect
 */
function consoleLogFull(v: any): void {
  console.log(util.inspect(v, {showHidden: false, depth: null}))
}

interface Source {
  url: string;
  content: string;
}

/**
 * @param fileURL
 * @return {boolean}
 */
function isURLFileTypeJS(fileURL: string): boolean {
  try {
    const url = new URL(fileURL);
    // Basic extension check. This avoids the query/hash at the end problem.
    if (url.pathname.endsWith(".js") || url.pathname.endsWith(".mjs")) {
      return true;
    }
    // TODO: may be improved by getting MIME type instead of extension.
    return false;
  } catch (e) {
    return false;
  }
}

type PackageStringsByVersionsToScan = {
  // Has to be a map: we want to keep version order
  [packageName: string]: Map<string, Set<string>> // strings that associate with this version of package
}

type PackageVersionCollector = {
  [packageName: string]: {
    [version: string]: Map<string, Set<string>> // List of hosts to ssource urls mapping that are most likely with this version.
  }
}

/**
 * Create the package strings to scan map from files.
 * @param filenames names to serialized package strings generated by collect_version_strings.ts
 */
function preparePackageStringsByVersionsToScan(filenames: string[]): PackageStringsByVersionsToScan {
  const output: PackageStringsByVersionsToScan = {};
  for (const filename of filenames) {
    const serializedContent = fs.readFileSync(filename, "utf8");
    const packageStringsByVersionMap = JSON.parse(serializedContent) as PackageStringsByVersionMapWithInfo;
    const packageVersionStrings = new Map<string, Set<string>>();
    for (const orderedVersion of packageStringsByVersionMap.versionOrder) {
      // Map keeps insertion order
      packageVersionStrings.set(orderedVersion, new Set(packageStringsByVersionMap.versions[orderedVersion]));
    }
    output[packageStringsByVersionMap.packageName] = packageVersionStrings;
  }
  return output;
}

// TODO: enter pre-prepared packages here.
const PACKAGE_STRINGS_BY_VERSION_JSON_FILENAMES = [
  "data/axios_strings.json",
  // "data/moment_strings.json",
  "data/uuid_strings.json",
  "data/core_js_strings.json",
  "data/jquery_strings.json"
].map(e => __dirname + "/" + e)
export const PACKAGE_STRINGS_BY_VERSION = preparePackageStringsByVersionsToScan(PACKAGE_STRINGS_BY_VERSION_JSON_FILENAMES);

/**
 * @param sources 
 * @param host 
 * @param packagesToScan 
 * @param packageVersionCollector collector of final data. Returned collector is the same reference as this one.
 * @param allowThirdParty NOT implemented
 */
export function staticScanForPackage(
  sources: Source[],
  host: string,
  packagesToScan: PackageStringsByVersionsToScan,
  packageVersionCollector: PackageVersionCollector,
  allowThirdParty = true
): PackageVersionCollector {
  for (const source of sources) {
    if (isURLFileTypeJS(source.url) /* && isFileLikelyFirstParty(source.url, host) */) { // TODO: enforce no third-party?
      try {
        const bundleStrs = collectNotableStrings(source.content, new Set(), Infinity, source.url);
        for (const packageName in packagesToScan) {
          const matchCountsByVersion = new Map();
          const packageVersionStringSet = packagesToScan[packageName];
          for (const [versionName, versionStringSet] of packageVersionStringSet.entries()) {
            const matchResult = testStringsOnBundleStrings(bundleStrs, versionStringSet);
            const numMatches = matchResult.matched.size;
            if (numMatches > MIN_MATCH_STRING_COUNT) {
              matchCountsByVersion.set(versionName, numMatches);
            }
          }
          let bestMatch: string | null = null;
          for (const [versionName, numMatches] of matchCountsByVersion.entries()) {
            // Either no prev best match, or that best match has a smaller num of matches then current.
            // Notice that we always iterate in the order of map insertion: this guarantees release order.
            if (bestMatch === null || matchCountsByVersion.get(bestMatch) < numMatches) {
              bestMatch = versionName;
            }
          }
          if (bestMatch !== null) {
            if (DISPLAY_MATCH_VERSION_STATS) {
              console.log(`>> For # strings in package "${packageName}" found on ${source.url}:`);
              consoleLogFull(matchCountsByVersion);
            }

            if (!(packageName in packageVersionCollector)) {
              packageVersionCollector[packageName] = {};
            }
            if (!(bestMatch in packageVersionCollector[packageName])) {
              packageVersionCollector[packageName][bestMatch] = new Map();
            }
            if (!packageVersionCollector[packageName][bestMatch].has(host)) {
              packageVersionCollector[packageName][bestMatch].set(host, new Set());
            }
            packageVersionCollector[packageName][bestMatch].get(host)!.add(source.url);
          }
        }
      } catch (_e) {}
    }
  }
  return packageVersionCollector;
}

async function runOnPage(page, domain, collector: PackageVersionCollector) {
  const sources: {url: string, content: string}[] = [];
  page.on("console", msg => {
    // TODO: msg.args() to capture console content
  });
  // page.evaluateOnNewDocument(() => {
  //   // TODO: add code that will be run in the browser context
  // });

  await page.setRequestInterception(true);
  page.on("request", async request => {
    try {
      if (request.isNavigationRequest() && request.redirectChain().length > 10) { // prevent too many redirects failure.
        await request.abort();
      } else {
        await request.continue();
      }
    } catch {}
  });

  // await page.setRequestInterception(true); // Used to inject custom scripts
  page.on("response", async response => {
    try {
      const content = await response.text(); // .toLowerCase(); // Don't do this!!!
      sources.push({ url: response.url(), content })
    } catch {
      // console.log(`x Response read failed for ${response.url()}`);
    }
  });

  debug(`Navigating to ${domain}`);
  // Racing between networkidle2 and a given timeout. If wait for TOO long, page explodes under puppeteer...
  await Promise.race([page.goto(domain, {waitUntil: "networkidle2"}), sleep(10000)])

  staticScanForPackage(sources, new URL(domain).hostname, PACKAGE_STRINGS_BY_VERSION, collector);

  debug(`Finish task for ${domain}`);

  // DEBUG: for evaluation purposes. Remove this later on in actuall running
  if (DISPLAY_REAL_JQUERY_VERSION_IF_PRESENT) {
    // Try to save jquery version from site if present, for later comparison with our string-based eval output.
    try {
      const jqueryVersion = await page.evaluate(function () {
        var jquery: any;
        // @ts-ignore
        if (window.$) {
          // @ts-ignore
          jquery = window.$;
        // @ts-ignore
        } else if (window.jQuery) {
          // @ts-ignore
          jquery = window.jQuery;
        }
        if (jquery && jquery.fn && jquery.fn.jquery) {
          return jquery.fn.jquery;
        } else {
          return null;
        }
      });
      if (jqueryVersion) {
        JQUERY_DEBUG_STATS[domain] = jqueryVersion;
      }
    } catch (_e) {}
  }

  try {
    // Kill the page when necessary. This is required to allow a clear profile when navigating to the next page.
    // page.evaluate also has the change of failure similar to above.
    await page.evaluate(() => window.stop());
  } catch (_e) {}
}

async function createCustomBrowser() {
  const customArgs = [
    `--load-extension=${path.resolve("../extensions/react_devtools/")}`,
    '--disable-dev-shm-usage'
  ];
  return {
    // defaultViewport: null,
    // executablePath: process.env.chrome,
    // headless: false, // WARNING: we have to make it NOT headless to get the extension to work! This is a sad compromise... See https://bugs.chromium.org/p/chromium/issues/detail?id=706008#c5
    ignoreDefaultArgs: ["--disable-extensions"],
    args: customArgs,
  };
}

export async function main(domains: string[]) {
  const browserArgs = await createCustomBrowser();
  const cluster = await Cluster.launch({
    concurrency: Cluster.CONCURRENCY_CONTEXT,
    maxConcurrency: 50,
    puppeteerOptions: browserArgs
  });
  console.log('starting browser...');

  const resultCollector: PackageVersionCollector = {};
  for (let domain of domains) {
    cluster.queue(async ({ page }) => {
      try {
        await runOnPage(page, domain, resultCollector);
      } catch (e) {
        console.error(`>>> on domain "${domain}"`, e);
      }
    });
  };

  await cluster.idle();
  debug("Shutting down cluster...");
  await cluster.close();
  debug("Done");

  if (DISPLAY_REAL_JQUERY_VERSION_IF_PRESENT) {
    console.log(">> Collected jQuery actual versions from dynamic eval:");
    consoleLogFull(JQUERY_DEBUG_STATS);
  }
  console.log(">> Collected analyzer result:");
  // TODO: consider writing this result to a file.
  consoleLogFull(resultCollector);
  return resultCollector;
}

/**
 * Using this comparison, we can use this file both as a module AND as a running file.
 * Usage: ts-node ./package_crawler ../example/top_100.csv
 */
if (require.main === module) {
  if (process.argv.length < 3) {
    console.error("Error: please provide filename of domains");
  }
  const domainCSVFilename = process.argv[2];
  const domainCSVRawContent = fs.readFileSync(domainCSVFilename, "utf8");
  const domains = parseCSV(domainCSVRawContent);

  // TODO: implement read csv file. need PR master merge.
  main(domains.map(d => `http://${d.Domain}`));
}

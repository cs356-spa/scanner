{
  "packageName": "bluebird",
  "versionOrder": [
    "0.7.1-1",
    "0.7.1-2",
    "0.7.1-3",
    "0.7.1-4",
    "0.7.1-5",
    "0.7.2-0",
    "0.7.3-0",
    "0.7.4-0",
    "0.7.4-1",
    "0.7.5-0",
    "0.7.6-0",
    "0.7.7-0",
    "0.7.7-1",
    "0.7.8-0",
    "0.7.8-1",
    "0.7.9-0",
    "0.7.9-1",
    "0.7.10-0",
    "0.7.10-1",
    "0.7.11-0",
    "0.7.12-0",
    "0.7.12-1",
    "0.7.12-2",
    "0.8.0-0",
    "0.8.0-1",
    "0.8.0-2",
    "0.8.0-3",
    "0.8.1-0",
    "0.8.2-0",
    "0.8.2-1",
    "0.8.2-2",
    "0.8.3-0",
    "0.8.3-1",
    "0.8.3-2",
    "0.8.3-3",
    "0.8.4-0",
    "0.8.4-1",
    "0.8.5-0",
    "0.8.5-1",
    "0.9.0-0",
    "0.9.1-0",
    "0.9.1-1",
    "0.9.2-0",
    "0.9.2-1",
    "0.9.3-0",
    "0.9.4-0",
    "0.9.4-1",
    "0.9.5-0",
    "0.9.6-0",
    "0.9.7-0",
    "0.9.8-0",
    "0.9.9-0",
    "0.9.10-0",
    "0.9.10-1",
    "0.9.11-0",
    "0.9.11-1",
    "0.10.0-0",
    "0.10.0-1",
    "0.10.1-0",
    "0.10.2-0",
    "0.10.2-1",
    "0.10.3-0",
    "0.10.4-0",
    "0.10.4-1",
    "0.10.5-0",
    "0.10.6-0",
    "0.10.7-0",
    "0.10.8-0",
    "0.10.9-0",
    "0.10.9-1",
    "0.10.10-0",
    "0.10.11-0",
    "0.10.11-1",
    "0.10.11-2",
    "0.10.11-4",
    "0.10.12-0",
    "0.10.13-0",
    "0.10.13-1",
    "0.10.14-0",
    "0.11.0-0",
    "0.11.1-0",
    "0.11.2-0",
    "0.11.3-0",
    "0.11.4-0",
    "0.11.4-1",
    "0.11.5-0",
    "0.11.5-1",
    "0.11.6-0",
    "0.11.6",
    "1.0.0",
    "1.0.1",
    "1.0.2",
    "1.0.3",
    "1.0.4",
    "1.0.5",
    "1.0.7",
    "1.0.8",
    "1.1.0",
    "1.1.1",
    "1.2.0",
    "1.2.1",
    "1.2.2",
    "1.2.3",
    "1.2.4",
    "2.0.2",
    "2.0.3",
    "2.0.4",
    "2.0.5",
    "2.0.6",
    "2.0.7",
    "2.1.1",
    "2.1.2",
    "2.1.3",
    "2.2.0",
    "2.2.1",
    "2.2.2",
    "2.3.0",
    "2.3.1",
    "2.3.2",
    "2.3.3",
    "2.3.4",
    "2.3.5",
    "2.3.6",
    "2.3.9",
    "2.3.10",
    "2.3.11",
    "2.4.0",
    "2.4.1",
    "2.4.2",
    "2.4.3",
    "2.5.0",
    "2.5.1",
    "2.5.2",
    "2.5.3",
    "2.6.0",
    "2.6.1",
    "2.6.2",
    "2.6.3",
    "2.6.4",
    "2.7.0",
    "2.7.1",
    "2.8.0",
    "2.8.1",
    "2.8.2",
    "2.9.0",
    "2.9.1",
    "2.9.2",
    "2.9.3",
    "2.9.4",
    "2.9.5",
    "2.9.6",
    "2.9.7",
    "2.9.8",
    "2.9.9",
    "2.9.10",
    "2.9.11",
    "2.9.12",
    "2.9.13",
    "2.9.14",
    "2.9.15",
    "2.9.16",
    "2.9.17",
    "2.9.18",
    "2.9.19",
    "2.9.20",
    "2.9.21",
    "2.9.22",
    "2.9.23",
    "2.9.24",
    "2.9.25",
    "2.9.26",
    "2.9.27",
    "2.9.28",
    "2.9.29",
    "2.9.30",
    "2.9.31",
    "2.9.32",
    "2.9.33",
    "2.9.34",
    "2.10.0",
    "2.10.1",
    "2.10.2",
    "2.11.0",
    "3.0.0",
    "3.0.1",
    "3.0.2",
    "3.0.3",
    "3.0.4",
    "3.0.5",
    "3.0.6",
    "3.1.0",
    "3.1.1",
    "3.1.2",
    "3.1.3",
    "3.1.4",
    "3.1.5",
    "3.2.0",
    "3.2.1",
    "3.2.2",
    "3.3.0",
    "3.3.1",
    "3.3.2",
    "3.3.3",
    "3.3.4",
    "3.3.5",
    "3.4.0",
    "3.4.1",
    "3.4.2",
    "3.4.3",
    "3.4.4",
    "3.4.5",
    "3.4.6",
    "3.4.7",
    "3.5.0",
    "3.5.1",
    "3.5.2",
    "3.5.3",
    "3.5.4",
    "3.5.5",
    "3.6.0",
    "3.7.0",
    "3.7.1",
    "3.7.2"
  ],
  "versions": {
    "0.7.1-5": [
      "callback.call(receiver, ",
      "return function promisified( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( promisified );",
      "var fn = function fn( err, value ) {",
      "resolver.reject( err );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      "default: callback.apply(receiver, arguments); break;",
      "return resolver.promise;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]"
    ],
    "0.7.1-4": [
      "callback.call(receiver, ",
      "return function promisified( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( promisified );",
      "var fn = function fn( err, value ) {",
      "resolver.reject( err );",
      "resolver.fulfill( value );",
      "default: callback.apply(receiver, arguments); break;",
      "return resolver.promise;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]"
    ],
    "0.7.3-0": [
      "callback.call(receiver, ",
      "return function promisified( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( promisified );",
      "var fn = function fn( err, value ) {",
      "resolver.reject( err );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      "default: callback.apply(receiver, arguments); break;",
      "return resolver.promise;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]"
    ],
    "0.7.4-0": [
      "callback.call(receiver, ",
      "return function promisified( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( promisified );",
      "var fn = function fn( err, value ) {",
      "resolver.reject( err );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      "default: callback.apply(receiver, arguments); break;",
      "return resolver.promise;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generator must be a function",
      "Attempting to use Promise.spawn ",
      "without generator support",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]"
    ],
    "0.7.2-0": [
      "callback.call(receiver, ",
      "return function promisified( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( promisified );",
      "var fn = function fn( err, value ) {",
      "resolver.reject( err );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      "default: callback.apply(receiver, arguments); break;",
      "return resolver.promise;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]"
    ],
    "0.7.4-1": [
      "callback.call(receiver, ",
      "return function promisified( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( promisified );",
      "var fn = function fn( err, value ) {",
      "resolver.reject( err );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      "default: callback.apply(receiver, arguments); break;",
      "return resolver.promise;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generator must be a function",
      "Attempting to use Promise.spawn ",
      "without generator support",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]"
    ],
    "0.7.5-0": [
      "callback.call(receiver, ",
      "return function promisified( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( promisified );",
      "var fn = function fn( err, value ) {",
      "resolver.reject( err );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      "default: callback.apply(receiver, arguments); break;",
      "return resolver.promise;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Attempting to use Promise.coroutine ",
      "without generatorFunction support",
      "Attempting to use Promise.spawn ",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]"
    ],
    "0.7.7-0": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = function fn( err, value ) {",
      "resolver.reject( err );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      ", withAppended( arguments, fn ) ); break;",
      "return resolver.promise;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Attempting to use Promise.coroutine ",
      "without generatorFunction support",
      "Attempting to use Promise.spawn ",
      "__processedBluebirdAsync__",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]"
    ],
    "0.7.7-1": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = function fn( err, value ) {",
      "resolver.reject( err );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      ", withAppended( arguments, fn ) ); break;",
      "return resolver.promise;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Attempting to use Promise.coroutine ",
      "without generatorFunction support",
      "Attempting to use Promise.spawn ",
      "__processedBluebirdAsync__",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]"
    ],
    "0.7.6-0": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = function fn( err, value ) {",
      "resolver.reject( err );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      ", withAppended( arguments, fn ) ); break;",
      "return resolver.promise;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Attempting to use Promise.coroutine ",
      "without generatorFunction support",
      "Attempting to use Promise.spawn ",
      "__processedBluebirdAsync__",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]"
    ],
    "0.7.8-0": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = function fn( err, value ) {",
      "resolver.reject( err );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      ", withAppended( arguments, fn ) ); break;",
      "return resolver.promise;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Attempting to use Promise.coroutine ",
      "without generatorFunction support",
      "Attempting to use Promise.spawn ",
      "__processedBluebirdAsync__",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]"
    ],
    "0.7.9-0": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = function fn( err, value ) {",
      "resolver.reject( err );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      ", withAppended( arguments, fn ) ); break;",
      "return resolver.promise;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Attempting to use Promise.coroutine ",
      "without generatorFunction support",
      "Attempting to use Promise.spawn ",
      "__processedBluebirdAsync__",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]"
    ],
    "0.7.8-1": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = function fn( err, value ) {",
      "resolver.reject( err );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      ", withAppended( arguments, fn ) ); break;",
      "return resolver.promise;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Attempting to use Promise.coroutine ",
      "without generatorFunction support",
      "Attempting to use Promise.spawn ",
      "__processedBluebirdAsync__",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]"
    ],
    "0.7.10-0": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = function fn( err, value ) {",
      "resolver.reject( err );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      ", withAppended( arguments, fn ) ); break;",
      "return resolver.promise;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Attempting to use Promise.coroutine ",
      "without generatorFunction support",
      "Attempting to use Promise.spawn ",
      "__processedBluebirdAsync__",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]"
    ],
    "0.7.9-1": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = function fn( err, value ) {",
      "resolver.reject( err );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      ", withAppended( arguments, fn ) ); break;",
      "return resolver.promise;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Attempting to use Promise.coroutine ",
      "without generatorFunction support",
      "Attempting to use Promise.spawn ",
      "__processedBluebirdAsync__",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]"
    ],
    "0.7.10-1": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = function fn( err, value ) {",
      "resolver.reject( err );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      ", withAppended( arguments, fn ) ); break;",
      "return resolver.promise;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Attempting to use Promise.coroutine ",
      "without generatorFunction support",
      "Attempting to use Promise.spawn ",
      "__processedBluebirdAsync__",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]"
    ],
    "0.7.12-0": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = function fn( err, value ) {",
      "resolver.reject( maybeWrapAsError( err ) );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Attempting to use Promise.coroutine ",
      "without generatorFunction support",
      "Attempting to use Promise.spawn ",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.7.12-2": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = function fn( err, value ) {",
      "resolver.reject( maybeWrapAsError( err ) );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.8.0-0": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = function fn( err, value ) {",
      "resolver.reject( maybeWrapAsError( err ) );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.8.0-2": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = function fn( err, value ) {",
      "resolver.reject( maybeWrapAsError( err ) );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.8.0-3": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.8.0-1": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = function fn( err, value ) {",
      "resolver.reject( maybeWrapAsError( err ) );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.7.11-0": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = function fn( err, value ) {",
      "resolver.reject( err );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      ", withAppended( arguments, fn ) ); break;",
      "return resolver.promise;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Attempting to use Promise.coroutine ",
      "without generatorFunction support",
      "Attempting to use Promise.spawn ",
      "__processedBluebirdAsync__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.7.12-1": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = function fn( err, value ) {",
      "resolver.reject( maybeWrapAsError( err ) );",
      "if( arguments.length > 2 ) {",
      "    var len = arguments.length;",
      "    var val = new Array(len - 1);",
      "    for( var i = 1; i < len; ++i ) {",
      "        val[ i - 1 ] = arguments[i];",
      "resolver.fulfill( value );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      ".prototype = create(Error.prototype);",
      ".prototype.constructor = ",
      "if( Error.captureStackTrace ) {",
      "Error.captureStackTrace(this, this.constructor);",
      "Error.call(this, msg);",
      "this.message = typeof msg === 'string'",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "^(?:__proto__|undefined|NaN|Infinity|this|false|true|null|eval|",
      "arguments|break|case|catch|continue|debugger|default|delete|do|",
      "else|finally|for|function|if|in|instanceof|new|return|switch|th",
      "row|try|typeof|var|void|while|with|class|enum|export|extends|im",
      "port|super|implements|interface|let|package|private|protected|pu",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "'use strict';return function Promise$_fulfiller(a){ p.fulfill( a ); }",
      "'use strict';return function Promise$_rejecter(a){ p.reject( a ); }",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.8.1-0": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "bluebird_message_key_",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.8.2-0": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "bluebird_message_key_",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.8.2-1": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "bluebird_message_key_",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.8.3-0": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "bluebird_message_key_",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.8.3-1": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "bluebird_message_key_",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.8.2-2": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "bluebird_message_key_",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.8.3-3": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "bluebird_message_key_",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.8.3-2": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "bluebird_message_key_",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.8.4-1": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "bluebird_message_key_",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.8.4-0": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "bluebird_message_key_",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.9.0-0": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "bluebird_message_key_",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.8.5-1": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "bluebird_message_key_",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.9.1-0": [
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "bluebird_message_key_",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "fn must be a function",
      "generatorFunction must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.9.1-1": [
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "bluebird_message_key_",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "fn must be a function",
      "generatorFunction must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.8.5-0": [
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      ", withAppended( arguments, fn ) ); break;",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "bluebird_message_key_",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "generatorFunction must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise"
    ],
    "0.7.1-1": [],
    "0.7.1-2": [],
    "0.7.1-3": [],
    "0.9.4-0": [],
    "0.9.2-1": [
      "./some_promise_array.js",
      "./any_promise_array.js",
      "./properties_promise_array.js",
      "./settled_promise_array.js",
      "./promise_inspection.js",
      "./promise_resolver.js",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "fn must be a function",
      "generatorFunction must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.9.2-0": [
      "./some_promise_array.js",
      "./any_promise_array.js",
      "./properties_promise_array.js",
      "./settled_promise_array.js",
      "./promise_inspection.js",
      "./promise_resolver.js",
      "A catch filter must be an error constructor",
      "howMany must be an integer",
      "fn is not a function",
      "fn must be a function",
      "generatorFunction must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "Circular thenable chain",
      "StopProgressPropagation",
      "expecting an array or a promise",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "From previous event:",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "[object PromiseResolver]",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "2.8.2": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            promise._setIsSpreadable();                                      \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        "
    ],
    "2.8.1": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./errors_api_rejection",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "./synchronous_inspection.js",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "[no string representation]",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "./errors_api_rejection.js",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            promise._setIsSpreadable();                                      \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation"
    ],
    "0.9.4-1": [
      "./promise_resolver.js",
      "A catch filter must be an error constructor",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "Circular thenable chain",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./any_promise_array.js",
      "fn is not a function",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      "generatorFunction must be a function",
      "./settled_promise_array.js",
      "./some_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.9.3-0": [
      "./promise_resolver.js",
      "A catch filter must be an error constructor",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "Circular thenable chain",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./any_promise_array.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      "./settled_promise_array.js",
      "./some_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.9.7-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "A catch filter must be an error constructor",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "Circular thenable chain",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "__BluebirdErrorTypes__",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./any_promise_array.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      "./some_promise_array.js",
      "howMany must be an integer",
      "./settled_promise_array.js",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.9.8-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "A catch filter must be an error constructor",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "Circular thenable chain",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "__BluebirdErrorTypes__",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./any_promise_array.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "./properties_promise_array.js",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./settled_promise_array.js",
      "./some_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "2.6.2": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "./errors_api_rejection",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "./synchronous_inspection.js",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "[no string representation]",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "From previous event:",
      "^--- With additional stack trace: ",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "you must pass at least 2 arguments to Promise.using",
      "A value was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(undefined);                                    \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "./errors_api_rejection.js",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        "
    ],
    "2.6.1": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "./errors_api_rejection",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "^--- With additional stack trace: ",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "you must pass at least 2 arguments to Promise.using",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "A value was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(undefined);                                    \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "StopProgressPropagation",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n"
    ],
    "2.5.2": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "./errors_api_rejection",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "./synchronous_inspection.js",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "[no string representation]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "^--- With additional stack trace: ",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "./errors_api_rejection.js",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "A value was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(undefined);                                    \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using"
    ],
    "2.6.0": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "./errors_api_rejection",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "^--- With additional stack trace: ",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(undefined);                                    \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation"
    ],
    "2.5.3": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "./errors_api_rejection",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "From previous event:",
      "^--- With additional stack trace: ",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "./errors_api_rejection.js",
      "A value was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(undefined);                                    \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using"
    ],
    "2.6.4": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "./errors_api_rejection",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "From previous event:",
      "^--- With additional stack trace: ",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(undefined);                                    \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "./errors_api_rejection.js",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation"
    ],
    "2.6.3": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "./errors_api_rejection",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "./synchronous_inspection.js",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "[no string representation]",
      "From previous event:",
      "^--- With additional stack trace: ",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "A value was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "you must pass at least 2 arguments to Promise.using",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(undefined);                                    \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation"
    ],
    "2.7.0": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "./errors_api_rejection",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "./synchronous_inspection.js",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "[no string representation]",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "From previous event:",
      "^--- With additional stack trace: ",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(undefined);                                    \n            promise._setIsSpreadable();                                      \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "./errors_api_rejection.js",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation"
    ],
    "2.7.1": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "./errors_api_rejection",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "./synchronous_inspection.js",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "[no string representation]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "From previous event:",
      "^--- With additional stack trace: ",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(undefined);                                    \n            promise._setIsSpreadable();                                      \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation"
    ],
    "2.8.0": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./errors_api_rejection",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "you must pass at least 2 arguments to Promise.using",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            promise._setIsSpreadable();                                      \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation"
    ],
    "0.9.11-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "Circular thenable chain",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "__BluebirdErrorTypes__",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "./promise_inspection.js",
      "[object PromiseResolver]",
      "./some_promise_array.js",
      "fn is not a function",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "generatorFunction must be a function",
      "./race_promise_array.js",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./settled_promise_array.js",
      "StopProgressPropagation",
      "howMany must be an integer",
      "./properties_promise_array.js",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.9.10-1": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "Circular thenable chain",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "__BluebirdErrorTypes__",
      "[object PromiseResolver]",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "./promise_inspection.js",
      "./race_promise_array.js",
      "./some_promise_array.js",
      "fn is not a function",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      "./settled_promise_array.js",
      "generatorFunction must be a function",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.9.10-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "Circular thenable chain",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "__BluebirdErrorTypes__",
      "[object PromiseResolver]",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./race_promise_array.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      "howMany must be an integer",
      "./settled_promise_array.js",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.9.9-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "A catch filter must be an error constructor",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "Circular thenable chain",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "__BluebirdErrorTypes__",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "./promise_inspection.js",
      "[object PromiseResolver]",
      "fn is not a function",
      "./some_promise_array.js",
      "generatorFunction must be a function",
      "./race_promise_array.js",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.9.11-1": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "Circular thenable chain",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "__BluebirdErrorTypes__",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "./some_promise_array.js",
      "./race_promise_array.js",
      "[object PromiseResolver]",
      "generatorFunction must be a function",
      "./promise_inspection.js",
      "fn is not a function",
      "./properties_promise_array.js",
      "howMany must be an integer",
      "./settled_promise_array.js",
      "StopProgressPropagation",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "2.0.3": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "operation timed out after",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "./errors_api_rejection.js",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method(args, fn);                                       \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, args, fn);                               \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, args, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback(args, fn);                                          \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "cannot await properties of a non-object",
      "(Promise.some) input array contains less than ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.0.5": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "expecting an array, a promise or a thenable",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "operation timed out after",
      "./errors_api_rejection.js",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "cannot await properties of a non-object",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method(args, fn);                                       \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, args, fn);                               \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, args, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback(args, fn);                                          \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "(Promise.some) input array contains less than ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.0.7": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "expecting an array, a promise or a thenable",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "operation timed out after",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method(args, fn);                                       \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, args, fn);                               \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, args, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback(args, fn);                                          \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "cannot await properties of a non-object",
      "(Promise.some) input array contains less than ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.1.3": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "operation timed out after",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "./errors_api_rejection.js",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method(args, fn);                                       \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, args, fn);                               \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, args, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback(args, fn);                                          \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "cannot await properties of a non-object",
      "(Promise.some) input array contains less than ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.0.4": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "expecting an array, a promise or a thenable",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "operation timed out after",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method(args, fn);                                       \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, args, fn);                               \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, args, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback(args, fn);                                          \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "cannot await properties of a non-object",
      "StopProgressPropagation",
      "(Promise.some) input array contains less than ",
      "expecting a positive integer",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.0.6": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "expecting an array, a promise or a thenable",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "operation timed out after",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "cannot await properties of a non-object",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method(args, fn);                                       \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, args, fn);                               \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, args, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback(args, fn);                                          \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "(Promise.some) input array contains less than ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.2.2": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "operation timed out after",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "./errors_api_rejection.js",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method(args, fn);                                       \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, args, fn);                               \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, args, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback(args, fn);                                          \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "cannot await properties of a non-object",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.2.1": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "expecting an array, a promise or a thenable",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "operation timed out after",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method(args, fn);                                       \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, args, fn);                               \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, args, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback(args, fn);                                          \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "cannot await properties of a non-object",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.4.3": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "./errors_api_rejection",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "^--- With additional stack trace: ",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "A value was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(undefined);                                    \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.1.1": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "expecting an array, a promise or a thenable",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "operation timed out after",
      "./errors_api_rejection.js",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method(args, fn);                                       \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, args, fn);                               \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, args, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback(args, fn);                                          \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "cannot await properties of a non-object",
      "(Promise.some) input array contains less than ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.1.2": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "operation timed out after",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "cannot await properties of a non-object",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method(args, fn);                                       \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, args, fn);                               \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, args, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback(args, fn);                                          \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "(Promise.some) input array contains less than ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.2.0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "operation timed out after",
      "./errors_api_rejection.js",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method(args, fn);                                       \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, args, fn);                               \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, args, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback(args, fn);                                          \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "cannot await properties of a non-object",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.5.1": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "./errors_api_rejection",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "^--- With additional stack trace: ",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "A value was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(undefined);                                    \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n"
    ],
    "2.4.0": [
      "circular promise resolution chain",
      "./promise_resolver.js",
      "./errors_api_rejection",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "^--- With additional stack trace: ",
      "From previous event:",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "expecting an array, a promise or a thenable",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "operation timed out after",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(undefined);                                    \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "cannot await properties of a non-object",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.4.1": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "./errors_api_rejection",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "From previous event:",
      "^--- With additional stack trace: ",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "A value was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(undefined);                                    \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.5.0": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "./errors_api_rejection",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "From previous event:",
      "^--- With additional stack trace: ",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "./errors_api_rejection.js",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(undefined);                                    \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "A value was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n"
    ],
    "2.4.2": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "./errors_api_rejection",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "^--- With additional stack trace: ",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "./errors_api_rejection.js",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "A value was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(undefined);                                    \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.0.2": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "expecting an array, a promise or a thenable",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "operation timed out after",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method(args, fn);                                       \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, args, fn);                               \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, args, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback(args, fn);                                          \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "cannot await properties of a non-object",
      "(Promise.some) input array contains less than ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.3.1": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "operation timed out after",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method(args, fn);                                       \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, args, fn);                               \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, args, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback(args, fn);                                          \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "cannot await properties of a non-object",
      "StopProgressPropagation",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.3.2": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "operation timed out after",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "cannot await properties of a non-object",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method(args, fn);                                       \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, args, fn);                               \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, args, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback(args, fn);                                          \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.3.3": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "expecting an array, a promise or a thenable",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "./errors_api_rejection.js",
      "operation timed out after",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method(args, fn);                                       \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, args, fn);                               \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, args, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback(args, fn);                                          \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "cannot await properties of a non-object",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.3.9": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "./errors_api_rejection.js",
      "operation timed out after",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "cannot await properties of a non-object",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.3.0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "./errors_api_rejection.js",
      "operation timed out after",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method(args, fn);                                       \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, args, fn);                               \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, args, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback(args, fn);                                          \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "cannot await properties of a non-object",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.3.5": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "operation timed out after",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "cannot await properties of a non-object",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.3.11": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "expecting an array, a promise or a thenable",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "operation timed out after",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "./errors_api_rejection.js",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "cannot await properties of a non-object",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.3.10": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "expecting an array, a promise or a thenable",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "operation timed out after",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "./errors_api_rejection.js",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "cannot await properties of a non-object",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.3.4": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "operation timed out after",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method(args, fn);                                       \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, args, fn);                               \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, args, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback(args, fn);                                          \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "cannot await properties of a non-object",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "2.3.6": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|3|4|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "operation timed out after",
      "./errors_api_rejection.js",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object",
      "A value was yielded that could not be treated as a promise",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API ",
      "that has normal methods with '",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function FunctionName(Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._setTrace(void 0);                                       \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function",
      "suffix must be a valid identifier",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer",
      "StopProgressPropagation",
      "you must pass at least 2 arguments to Promise.using",
      "no async scheduler available"
    ],
    "0.10.0-1": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Resolving promises cyclically",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "__BluebirdErrorTypes__",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./race_promise_array.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "./properties_promise_array.js",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./settled_promise_array.js",
      "StopProgressPropagation",
      "howMany must be an integer",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.6-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Resolving promises cyclically",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./race_promise_array.js",
      "generatorFunction must be a function",
      "fn is not a function",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "./settled_promise_array.js",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.0-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Resolving promises cyclically",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "__BluebirdErrorTypes__",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "./some_promise_array.js",
      "./race_promise_array.js",
      "generatorFunction must be a function",
      "fn is not a function",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./promise_inspection.js",
      "./properties_promise_array.js",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.2-1": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Resolving promises cyclically",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "__BluebirdErrorTypes__",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "./some_promise_array.js",
      "./race_promise_array.js",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "fn is not a function",
      "generatorFunction must be a function",
      "./promise_inspection.js",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "./properties_promise_array.js",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.2-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Resolving promises cyclically",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "__BluebirdErrorTypes__",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "./race_promise_array.js",
      "./some_promise_array.js",
      "./promise_inspection.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.10-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Circular promise resolution chain",
      "You must pass a resolver function ",
      "as the sole argument to the promise constructor",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./race_promise_array.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      ".props cannot be used on a primitive value",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.4-1": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Resolving promises cyclically",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "__BluebirdErrorTypes__",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./race_promise_array.js",
      "generatorFunction must be a function",
      "fn is not a function",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.4-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Resolving promises cyclically",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "__BluebirdErrorTypes__",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "./promise_inspection.js",
      "./race_promise_array.js",
      "./some_promise_array.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "./properties_promise_array.js",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.1-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Resolving promises cyclically",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "__BluebirdErrorTypes__",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./race_promise_array.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "./properties_promise_array.js",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.7-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Circular promise resolution chain",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|process._tic",
      "kCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./race_promise_array.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "./properties_promise_array.js",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "howMany must be an integer",
      "./settled_promise_array.js",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.11-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Circular promise resolution chain",
      "You must pass a resolver function ",
      "as the sole argument to the promise constructor",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "fn is not a function",
      "./race_promise_array.js",
      "./some_promise_array.js",
      "generatorFunction must be a function",
      "./properties_promise_array.js",
      ".props cannot be used on a primitive value",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "__beforePromisified__",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.9-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Circular promise resolution chain",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./race_promise_array.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./settled_promise_array.js",
      "./properties_promise_array.js",
      ".props cannot be used on a primitive value",
      "StopProgressPropagation",
      "howMany must be an integer",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.11-1": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Circular promise resolution chain",
      "You must pass a resolver function ",
      "as the sole argument to the promise constructor",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      ".props cannot be used on a primitive value",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.9-1": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Circular promise resolution chain",
      "You must pass a resolver function ",
      "as the sole argument to the promise constructor",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "./some_promise_array.js",
      "./race_promise_array.js",
      "./promise_inspection.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      ".props cannot be used on a primitive value",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.5-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Resolving promises cyclically",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "__BluebirdErrorTypes__",
      "[object PromiseResolver]",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./race_promise_array.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.12-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Circular promise resolution chain",
      "You must pass a resolver function ",
      "as the sole argument to the promise constructor",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      ".props cannot be used on a primitive value",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.11-2": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Circular promise resolution chain",
      "You must pass a resolver function ",
      "as the sole argument to the promise constructor",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      ".props cannot be used on a primitive value",
      "howMany must be an integer",
      "./settled_promise_array.js",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.3-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Resolving promises cyclically",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "__BluebirdErrorTypes__",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./race_promise_array.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.13-1": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Circular promise resolution chain",
      "You must pass a resolver function ",
      "as the sole argument to the promise constructor",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "[object PromiseResolver]",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "./some_promise_array.js",
      "./promise_inspection.js",
      "./errors_api_rejection.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./settled_promise_array.js",
      "./properties_promise_array.js",
      ".props cannot be used on a primitive value",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.14-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Circular promise resolution chain",
      "You must pass a resolver function ",
      "as the sole argument to the promise constructor",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "./properties_promise_array.js",
      ".props cannot be used on a primitive value",
      "__beforePromisified__",
      "var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "(a1, a2, a3, a4, a5) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending(",
      "var fn = nodebackForResolver(resolver);",
      "resolver.reject(maybeWrapAsError(e));",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.13-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Circular promise resolution chain",
      "You must pass a resolver function ",
      "as the sole argument to the promise constructor",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      ".props cannot be used on a primitive value",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.11-4": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Circular promise resolution chain",
      "You must pass a resolver function ",
      "as the sole argument to the promise constructor",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "generatorFunction must be a function",
      "fn is not a function",
      "__beforePromisified__",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      ".props cannot be used on a primitive value",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.10.8-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Circular promise resolution chain",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|process._tic",
      "kCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./race_promise_array.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "1.2.3": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "operation timed out after",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "./properties_promise_array.js",
      "cannot await properties of a non-object",
      "Cannot promisify an API ",
      "that has normal methods with Async-suffix",
      "default: var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "promise._setTrace(void 0);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.",
      "the target of promisifyAll must be an object or a function",
      "expecting a positive integer",
      "./settled_promise_array.js",
      "StopProgressPropagation",
      "(Promise.some) input array contains less than ",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "1.2.0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "./some_promise_array.js",
      "operation timed out after",
      "./errors_api_rejection.js",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "__beforePromisified__",
      "default: var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "promise._setTrace(void 0);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.",
      "the target of promisifyAll must be an object or a function",
      "./properties_promise_array.js",
      "cannot await properties of a non-object",
      "./settled_promise_array.js",
      "expecting a positive integer",
      "StopProgressPropagation",
      "(Promise.some) input array contains less than ",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "1.2.1": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "operation timed out after",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "__beforePromisified__",
      "default: var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "promise._setTrace(void 0);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.",
      "the target of promisifyAll must be an object or a function",
      "./properties_promise_array.js",
      "cannot await properties of a non-object",
      "expecting a positive integer",
      "./settled_promise_array.js",
      "StopProgressPropagation",
      "(Promise.some) input array contains less than ",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "1.2.2": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "[object PromiseResolver]",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "operation timed out after",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API ",
      "that has normal methods with Async-suffix",
      "default: var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "promise._setTrace(void 0);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.",
      "the target of promisifyAll must be an object or a function",
      "./properties_promise_array.js",
      "cannot await properties of a non-object",
      "./settled_promise_array.js",
      "expecting a positive integer",
      "StopProgressPropagation",
      "(Promise.some) input array contains less than ",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "1.2.4": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[a-zA-Z0-9.]+\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "operation timed out after",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "Cannot promisify an API ",
      "that has normal methods with Async-suffix",
      "default: var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "promise._setTrace(void 0);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.",
      "the target of promisifyAll must be an object or a function",
      "./properties_promise_array.js",
      "cannot await properties of a non-object",
      "./settled_promise_array.js",
      "expecting a positive integer",
      "StopProgressPropagation",
      "(Promise.some) input array contains less than ",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "1.1.1": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "operation timed out after",
      "./errors_api_rejection.js",
      "./some_promise_array.js",
      "__beforePromisified__",
      "default: var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.",
      "the target of promisifyAll must be an object or a function",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "./properties_promise_array.js",
      "cannot await properties of a non-object",
      "./settled_promise_array.js",
      "expecting a positive integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "(Promise.some) input array contains less than ",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "2.9.2": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            promise._setIsSpreadable();                                      \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation"
    ],
    "2.9.1": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            promise._setIsSpreadable();                                      \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation"
    ],
    "2.9.3": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[no string representation]",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            promise._setIsSpreadable();                                      \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        "
    ],
    "2.9.4": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            promise._setIsSpreadable();                                      \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "StopProgressPropagation",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n"
    ],
    "2.9.5": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            promise._setIsSpreadable();                                      \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation"
    ],
    "2.9.0": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            promise._setIsSpreadable();                                      \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "                                             \n        'use strict'                                                         \n        var len = this.length;                                               \n        switch(len) {                                                        \n            case 1: return obj.methodName(this[0]);                          \n            case 2: return obj.methodName(this[0], this[1]);                 \n            case 3: return obj.methodName(this[0], this[1], this[2]);        \n            case 0: return obj.methodName();                                 \n            default: return obj.methodName.apply(obj, this);                 \n        }                                                                    \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation"
    ],
    "0.11.0-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Circular promise resolution chain",
      "You must pass a resolver function ",
      "as the sole argument to the promise constructor",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "Operation timed out after ",
      "Promise.delay expects a positive integer",
      "Promise.prototype.timeout ",
      "expects a positive integer",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "generatorFunction must be a function",
      "fn is not a function",
      "__beforePromisified__",
      "var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "(a1, a2, a3, a4, a5) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending(",
      "var fn = nodebackForResolver(resolver);",
      "resolver.reject(maybeWrapAsError(e));",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      ".props cannot be used on a primitive value",
      "howMany must be an integer",
      "./settled_promise_array.js",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "2.9.7": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch(fn);                                     \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "you must pass at least 2 arguments to Promise.using",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "StopProgressPropagation"
    ],
    "2.9.8": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "StopProgressPropagation",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n"
    ],
    "2.9.13": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "StopProgressPropagation",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n"
    ],
    "2.9.12": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation"
    ],
    "2.9.9": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation"
    ],
    "2.9.11": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation"
    ],
    "2.9.6": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "                                                          \n                this.method({{args}}, fn);                                   \n                break;                                                       \n            ",
      "                                                         \n                callback.call(this, {{args}}, fn);                           \n                break;                                                       \n            ",
      "                                                         \n                callback.call(receiver, {{args}}, fn);                       \n                break;                                                       \n            ",
      "                                                         \n                callback({{args}}, fn);                                      \n                break;                                                       \n            ",
      "                                                  \n                this.property.apply(this, args);                             \n            ",
      "                                                  \n                callback.apply(this, args);                                  \n            ",
      "                                                  \n                callback.apply(receiver, args);                              \n            ",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = fn;                                                    \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "                                         \n        var ret = function (Parameters) {                        \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            promise._setIsSpreadable();                                      \n            var fn = nodebackForPromise(promise);                            \n            try {                                                            \n                switch(len) {                                                \n                    [CodeForSwitchCase]                                      \n                }                                                            \n            } catch (e) {                                                    \n                var wrapped = maybeWrapAsError(e);                           \n                promise._attachExtraTrace(wrapped);                          \n                promise._reject(wrapped);                                    \n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation"
    ],
    "2.9.15": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.9.16": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.9.10": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation"
    ],
    "2.9.14": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "StopProgressPropagation"
    ],
    "0.11.1-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Circular promise resolution chain",
      "You must pass a resolver function ",
      "as the sole argument to the promise constructor",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "Operation timed out after ",
      "Promise.delay expects a positive integer",
      "Promise.prototype.timeout ",
      "expects a positive integer",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "(a1, a2, a3, a4, a5) {\"use strict\";",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "var fn = nodebackForPromise(promise);",
      "promise._reject(maybeWrapAsError(e));",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      ".props cannot be used on a primitive value",
      "./settled_promise_array.js",
      "StopProgressPropagation",
      "howMany must be an integer",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.11.4-1": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Circular promise resolution chain",
      "You must pass a resolver function ",
      "as the sole argument to the promise constructor",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "__BluebirdErrorTypes__",
      "[object PromiseResolver]",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "Operation timed out after ",
      "Promise.delay expects a positive integer",
      "Promise.prototype.timeout ",
      "expects a positive integer",
      "./promise_inspection.js",
      "./errors_api_rejection.js",
      "generatorFunction must be a function",
      "./some_promise_array.js",
      "fn is not a function",
      "./properties_promise_array.js",
      ".props cannot be used on a primitive value",
      "__beforePromisified__",
      "var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "(a1, a2, a3, a4, a5) {\"use strict\";",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./settled_promise_array.js",
      "StopProgressPropagation",
      "howMany must be a positive integer",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "(Promise.some) input array contains less than ",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.11.2-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Circular promise resolution chain",
      "You must pass a resolver function ",
      "as the sole argument to the promise constructor",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "Operation timed out after ",
      "Promise.delay expects a positive integer",
      "Promise.prototype.timeout ",
      "expects a positive integer",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "generatorFunction must be a function",
      "fn is not a function",
      "./properties_promise_array.js",
      ".props cannot be used on a primitive value",
      "__beforePromisified__",
      "var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "(a1, a2, a3, a4, a5) {\"use strict\";",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "var fn = nodebackForPromise(promise);",
      "promise._reject(maybeWrapAsError(e));",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "StopProgressPropagation",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.11.4-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Circular promise resolution chain",
      "You must pass a resolver function ",
      "as the sole argument to the promise constructor",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Operation timed out after ",
      "Promise.delay expects a positive integer",
      "Promise.prototype.timeout ",
      "expects a positive integer",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "(a1, a2, a3, a4, a5) {\"use strict\";",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      ".props cannot be used on a primitive value",
      "./settled_promise_array.js",
      "howMany must be a positive integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.11.3-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "Circular promise resolution chain",
      "You must pass a resolver function ",
      "as the sole argument to the promise constructor",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "Operation timed out after ",
      "Promise.delay expects a positive integer",
      "Promise.prototype.timeout ",
      "expects a positive integer",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "(a1, a2, a3, a4, a5) {\"use strict\";",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "var fn = nodebackForPromise(promise);",
      "promise._reject(maybeWrapAsError(e));",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./properties_promise_array.js",
      ".props cannot be used on a primitive value",
      "./settled_promise_array.js",
      "howMany must be an integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "1.0.0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "./promise_inspection.js",
      "[object PromiseResolver]",
      "operation timed out after",
      "expecting a positive integer",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "generatorFunction must be a function",
      "./properties_promise_array.js",
      "cannot await properties of a non-object",
      "./settled_promise_array.js",
      "__beforePromisified__",
      "var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "(a1, a2, a3, a4, a5) {\"use strict\";",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.",
      "the target of promisifyAll must be an object or a function",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "(Promise.some) input array contains less than ",
      "bluebird_message_key_"
    ],
    "0.11.6-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "operation timed out after",
      "expecting a positive integer",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "./promise_inspection.js",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "(a1, a2, a3, a4, a5) {\"use strict\";",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.",
      "the target of promisifyAll must be an object or a function",
      "./properties_promise_array.js",
      "cannot await properties of a non-object",
      "StopProgressPropagation",
      "./settled_promise_array.js",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "(Promise.some) input array contains less than ",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "1.0.4": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "operation timed out after",
      "./promise_inspection.js",
      "./errors_api_rejection.js",
      "./some_promise_array.js",
      "generatorFunction must be a function",
      "./properties_promise_array.js",
      "cannot await properties of a non-object",
      "__beforePromisified__",
      "var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "(a1, a2, a3, a4, a5) {\"use strict\";",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.",
      "the target of promisifyAll must be an object or a function",
      "./settled_promise_array.js",
      "expecting a positive integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "(Promise.some) input array contains less than ",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "1.0.3": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "operation timed out after",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "(a1, a2, a3, a4, a5) {\"use strict\";",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.",
      "the target of promisifyAll must be an object or a function",
      "./properties_promise_array.js",
      "cannot await properties of a non-object",
      "./settled_promise_array.js",
      "expecting a positive integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "(Promise.some) input array contains less than ",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "1.0.8": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "operation timed out after",
      "[object PromiseResolver]",
      "./some_promise_array.js",
      "./promise_inspection.js",
      "generatorFunction must be a function",
      "./errors_api_rejection.js",
      "__beforePromisified__",
      "default: var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.",
      "the target of promisifyAll must be an object or a function",
      "./properties_promise_array.js",
      "cannot await properties of a non-object",
      "expecting a positive integer",
      "StopProgressPropagation",
      "./settled_promise_array.js",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "(Promise.some) input array contains less than ",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "1.0.1": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "__BluebirdErrorTypes__",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "operation timed out after",
      "./promise_inspection.js",
      "./errors_api_rejection.js",
      "./some_promise_array.js",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "(a1, a2, a3, a4, a5) {\"use strict\";",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.",
      "the target of promisifyAll must be an object or a function",
      "./settled_promise_array.js",
      "./properties_promise_array.js",
      "cannot await properties of a non-object",
      "expecting a positive integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "(Promise.some) input array contains less than ",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.11.5-1": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "__BluebirdErrorTypes__",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "operation timed out after",
      "expecting a positive integer",
      "generatorFunction must be a function",
      "./properties_promise_array.js",
      "cannot await properties of a non-object",
      "__beforePromisified__",
      "var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "(a1, a2, a3, a4, a5) {\"use strict\";",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.",
      "the target of promisifyAll must be an object or a function",
      "./settled_promise_array.js",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "(Promise.some) input array contains less than ",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.11.6": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "operation timed out after",
      "expecting a positive integer",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "(a1, a2, a3, a4, a5) {\"use strict\";",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.",
      "the target of promisifyAll must be an object or a function",
      "./properties_promise_array.js",
      "cannot await properties of a non-object",
      "./settled_promise_array.js",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "(Promise.some) input array contains less than ",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "1.0.5": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "operation timed out after",
      "./some_promise_array.js",
      "generatorFunction must be a function",
      "./errors_api_rejection.js",
      "__beforePromisified__",
      "default: var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.",
      "the target of promisifyAll must be an object or a function",
      "./properties_promise_array.js",
      "cannot await properties of a non-object",
      "./settled_promise_array.js",
      "expecting a positive integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "(Promise.some) input array contains less than ",
      "bluebird_message_key_"
    ],
    "1.0.7": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "operation timed out after",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "generatorFunction must be a function",
      "__beforePromisified__",
      "default: var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.",
      "the target of promisifyAll must be an object or a function",
      "./properties_promise_array.js",
      "cannot await properties of a non-object",
      "./settled_promise_array.js",
      "expecting a positive integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "(Promise.some) input array contains less than ",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "1.0.2": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "operation timed out after",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "generatorFunction must be a function",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "__beforePromisified__",
      "var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "(a1, a2, a3, a4, a5) {\"use strict\";",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.",
      "the target of promisifyAll must be an object or a function",
      "./settled_promise_array.js",
      "./properties_promise_array.js",
      "cannot await properties of a non-object",
      "expecting a positive integer",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "(Promise.some) input array contains less than ",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.11.5-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./errors_api_rejection.js",
      "./some_promise_array.js",
      "generatorFunction must be a function",
      "operation timed out after",
      "expecting a positive integer",
      "__beforePromisified__",
      "var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "(a1, a2, a3, a4, a5) {\"use strict\";",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.",
      "the target of promisifyAll must be an object or a function",
      "./settled_promise_array.js",
      "StopProgressPropagation",
      "./properties_promise_array.js",
      "cannot await properties of a non-object",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "(Promise.some) input array contains less than ",
      "bluebird_message_key_"
    ],
    "1.1.0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "circular promise resolution chain",
      "the promise constructor requires a resolver function",
      "the promise constructor cannot be invoked directly",
      "A catch filter must be an error constructor ",
      "or a filter function",
      "fn must be a function",
      "cannot enable long stack traces after promises have been created",
      "expecting an array, a promise or a thenable",
      "./synchronous_inspection.js",
      "__BluebirdErrorTypes__",
      "Catch filter must inherit from Error ",
      "or be a simple predicate function",
      "\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|",
      "tryCatch(?:1|2|Apply)|new \\w*PromiseArray|",
      "\\w*PromiseArray\\.\\w*PromiseArray|",
      "setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|",
      "process._tickCallback|nextTick|Async\\$\\w+)\\b",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "operation timed out after",
      "./promise_inspection.js",
      "./some_promise_array.js",
      "./errors_api_rejection.js",
      "generatorFunction must be a function",
      "Promise.spawn is deprecated. Use Promise.coroutine instead.",
      "./properties_promise_array.js",
      "cannot await properties of a non-object",
      "__beforePromisified__",
      "default: var args = new Array(len + 1);",
      "for (var i = 0; i < len; ++i) { ",
      "   args[i] = arguments[i];",
      "var len = arguments.length;",
      "var promise = new Promise(INTERNAL);",
      "var fn = nodebackForPromise(promise);",
      "var wrapped = maybeWrapAsError(e);",
      "promise._attachExtraTrace(wrapped);",
      "promise._reject(wrapped);",
      "}; ret.__isPromisified__ = true; return ret;",
      "Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.",
      "the target of promisifyAll must be an object or a function",
      "expecting a positive integer",
      "./settled_promise_array.js",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "(Promise.some) input array contains less than ",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "2.9.18": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "StopProgressPropagation",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.9.17": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "StopProgressPropagation",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.9.22": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "[no string representation]",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "StopProgressPropagation",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.9.21": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.9.26": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n"
    ],
    "2.9.25": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.9.20": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "[no string representation]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "you must pass at least 2 arguments to Promise.using",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.9.19": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.9.24": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.9.23": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.9.28": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.10.2": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "_makeSelfResolutionError",
      "./synchronous_inspection.js",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "[no string representation]",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.9.34": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "_makeSelfResolutionError",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "StopProgressPropagation",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.9.27": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "[no string representation]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        ret.__isPromisified__ = true;                                        \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n"
    ],
    "2.9.31": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "_makeSelfResolutionError",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.11.0": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "_makeSelfResolutionError",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "you must pass at least 2 arguments to Promise.using",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.10.1": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "_makeSelfResolutionError",
      "./synchronous_inspection.js",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[no string representation]",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "StopProgressPropagation",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.9.29": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "StopProgressPropagation",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.9.30": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.10.0": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "_makeSelfResolutionError",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "you must pass at least 2 arguments to Promise.using",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.9.32": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "_makeSelfResolutionError",
      "./synchronous_inspection.js",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "StopProgressPropagation",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "2.9.33": [
      "circular promise resolution chain\n\n    See http://goo.gl/LhFpo0\n",
      "./promise_resolver.js",
      "the promise constructor requires a resolver function\n\n    See http://goo.gl/EC22Yn\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/KsIlge\n",
      "Catch filter must inherit from Error or be a simple predicate function\n\n    See http://goo.gl/o84o68\n",
      ".then() only accepts functions but was passed: ",
      "fn must be a function\n\n    See http://goo.gl/916lJJ\n",
      "_makeSelfResolutionError",
      "./synchronous_inspection.js",
      "No async scheduler available\n\n    See http://goo.gl/m3OTXk\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "expecting an array, a promise or a thenable\n\n    See http://goo.gl/s8MMhc\n",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/DT1qyG\n",
      "[no string representation]",
      "[object PromiseResolver]",
      "Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\n\n    See http://goo.gl/sdkXL9\n",
      "StopProgressPropagation",
      "From previous event:",
      "    (No stack trace)",
      "^--- With additional stack trace: ",
      "Unhandled rejection ",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/hc1DLj\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/hPuiwB\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                                      \n            'use strict';                                                    \n            var callback = holder.fn;                                        \n            return callback(values);                                         \n            ",
      "you must pass at least 2 arguments to Promise.using",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/4Y4pDk\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/6Vqhm0\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/OsFKC8\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/1wAmHx\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/iWrZbw\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                            \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise);                      \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n        ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/9ITlV0\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/8FZo5V\n"
    ],
    "3.7.0": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "Catch statement predicate: ",
      "expecting an object but got ",
      "The last argument to .catch() ",
      "must be a function, got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "tapCatch statement predicate: ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "'concurrency' must be a number but it is ",
      "options argument must be an object but it is ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "you must pass at least 2 arguments to Promise.using",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "_unhandledRejectionCheck",
      "_unhandledRejectionClear",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "but was not returned from it, ",
      "see http://goo.gl/rRqMUw",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.7.1": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "Catch statement predicate: ",
      "expecting an object but got ",
      "The last argument to .catch() ",
      "must be a function, got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "tapCatch statement predicate: ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "'concurrency' must be a number but it is ",
      "options argument must be an object but it is ",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "you must pass at least 2 arguments to Promise.using",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "_unhandledRejectionCheck",
      "_unhandledRejectionClear",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "but was not returned from it, ",
      "see http://goo.gl/rRqMUw",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.6.0": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "Catch statement predicate: ",
      "expecting an object but got ",
      "The last argument to .catch() ",
      "must be a function, got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "tapCatch statement predicate: ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "'concurrency' must be a number but it is ",
      "options argument must be an object but it is ",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "you must pass at least 2 arguments to Promise.using",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "_unhandledRejectionCheck",
      "_unhandledRejectionClear",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "but was not returned from it, ",
      "see http://goo.gl/rRqMUw",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.7.2": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "Catch statement predicate: ",
      "expecting an object but got ",
      "The last argument to .catch() ",
      "must be a function, got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an array or an iterable object but got ",
      "tapCatch statement predicate: ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "'concurrency' must be a number but it is ",
      "options argument must be an object but it is ",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "you must pass at least 2 arguments to Promise.using",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "_unhandledRejectionCheck",
      "_unhandledRejectionClear",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "but was not returned from it, ",
      "see http://goo.gl/rRqMUw",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.1.0": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "you must pass at least 2 arguments to Promise.using",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.2.2": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "you must pass at least 2 arguments to Promise.using",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.0.0": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "a promise was created in a handler but ",
      "none were returned from it",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an array or an iterable object but got ",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "you must pass at least 2 arguments to Promise.using",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true);      \n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      " handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.0.4": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "a promise was created in a handler but ",
      "none were returned from it",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an array or an iterable object but got ",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "calling Promise.try with more than 1 argument",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "cancellation is disabled",
      "you must pass at least 2 arguments to Promise.using",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      " handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.0.5": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an array or an iterable object but got ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "you must pass at least 2 arguments to Promise.using",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      " handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.1.2": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.1.1": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "expecting an array or an iterable object but got ",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "cancellation is disabled",
      "calling Promise.try with more than 1 argument",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "you must pass at least 2 arguments to Promise.using",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.0.1": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "a promise was created in a handler but ",
      "none were returned from it",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "[no string representation]",
      "expecting an array or an iterable object but got ",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true);      \n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      " handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.2.0": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an array or an iterable object but got ",
      "calling Promise.try with more than 1 argument",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "cancellation is disabled",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.1.5": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.0.2": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "a promise was created in a handler but ",
      "none were returned from it",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an array or an iterable object but got ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true);      \n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      " handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.1.4": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an array or an iterable object but got ",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "calling Promise.try with more than 1 argument",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "cancellation is disabled",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "you must pass at least 2 arguments to Promise.using",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.3.2": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.0.3": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "a promise was created in a handler but ",
      "none were returned from it",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "cancellation is disabled",
      "calling Promise.try with more than 1 argument",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      " handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.4.0": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an array or an iterable object but got ",
      "[no string representation]",
      "calling Promise.try with more than 1 argument",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "'concurrency' must be a number but it is ",
      "options argument must be an object but it is ",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "cancellation is disabled",
      "you must pass at least 2 arguments to Promise.using",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.3.4": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an array or an iterable object but got ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.3.3": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.0.6": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      " handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.4.1": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "'concurrency' must be a number but it is ",
      "options argument must be an object but it is ",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.4.5": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      "A catch statement predicate ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "expecting an array or an iterable object but got ",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "calling Promise.try with more than 1 argument",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "cancellation is disabled",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "'concurrency' must be a number but it is ",
      "options argument must be an object but it is ",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "but was not returned from it, ",
      "see http://goo.gl/rRqMUw",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.4.4": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      "A catch statement predicate ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ",
      "'concurrency' must be a number but it is ",
      "options argument must be an object but it is ",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "but was not returned from it, ",
      "see http://goo.gl/rRqMUw",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.3.5": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "cancellation is disabled",
      "calling Promise.try with more than 1 argument",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "you must pass at least 2 arguments to Promise.using",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.4.3": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      "A catch statement predicate ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "'concurrency' must be a number but it is ",
      "options argument must be an object but it is ",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "but was not returned from it, ",
      "see http://goo.gl/rRqMUw",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.2.1": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.5.4": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "Catch statement predicate: ",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "tapCatch statement predicate: ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ",
      "'concurrency' must be a number but it is ",
      "options argument must be an object but it is ",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "but was not returned from it, ",
      "see http://goo.gl/rRqMUw",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.4.7": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      "A catch statement predicate ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an array or an iterable object but got ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "'concurrency' must be a number but it is ",
      "options argument must be an object but it is ",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "you must pass at least 2 arguments to Promise.using",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "but was not returned from it, ",
      "see http://goo.gl/rRqMUw",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.5.0": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "Catch statement predicate: ",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an array or an iterable object but got ",
      "tapCatch statement predicate: ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "you must pass at least 2 arguments to Promise.using",
      "'concurrency' must be a number but it is ",
      "options argument must be an object but it is ",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "but was not returned from it, ",
      "see http://goo.gl/rRqMUw",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.1.3": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.5.1": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "Catch statement predicate: ",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "tapCatch statement predicate: ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ",
      "'concurrency' must be a number but it is ",
      "options argument must be an object but it is ",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "but was not returned from it, ",
      "see http://goo.gl/rRqMUw",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.5.2": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "Catch statement predicate: ",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "tapCatch statement predicate: ",
      "cancellation is disabled",
      "calling Promise.try with more than 1 argument",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ",
      "'concurrency' must be a number but it is ",
      "options argument must be an object but it is ",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "but was not returned from it, ",
      "see http://goo.gl/rRqMUw",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.5.3": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "Catch statement predicate: ",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "expecting an array or an iterable object but got ",
      "tapCatch statement predicate: ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "'concurrency' must be a number but it is ",
      "options argument must be an object but it is ",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "but was not returned from it, ",
      "see http://goo.gl/rRqMUw",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.5.5": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "Catch statement predicate: ",
      "expecting an object but got ",
      "The last argument to .catch() ",
      "must be a function, got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an array or an iterable object but got ",
      "tapCatch statement predicate: ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "'concurrency' must be a number but it is ",
      "options argument must be an object but it is ",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "you must pass at least 2 arguments to Promise.using",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "but was not returned from it, ",
      "see http://goo.gl/rRqMUw",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.4.6": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      "A catch statement predicate ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "expecting an array or an iterable object but got ",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ",
      "'concurrency' must be a number but it is ",
      "options argument must be an object but it is ",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "but was not returned from it, ",
      "see http://goo.gl/rRqMUw",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.3.0": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an array or an iterable object but got ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.4.2": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      "A catch statement predicate ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "[no string representation]",
      "__BluebirdErrorTypes__",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an array or an iterable object but got ",
      "calling Promise.try with more than 1 argument",
      "cancellation is disabled",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "'concurrency' must be a number but it is ",
      "options argument must be an object but it is ",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "handler but was not returned from it. http://goo.gl/rRqMUw",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "3.3.1": [
      "circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n",
      "expecting a function but got ",
      "the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n",
      "expecting an object but got ",
      ".then() only accepts functions but was passed: ",
      ".all() was passed arguments but it does not take any",
      "late cancellation observer",
      "a promise was rejected with a non-error: ",
      "cannot .spread() a non-array: ",
      "_makeSelfResolutionError",
      "./synchronous_inspection",
      "join pop push shift unshift slice filter forEach some ",
      "every map indexOf lastIndexOf reduce reduceRight sort reverse",
      "[Circular AggregateError]",
      "__BluebirdErrorTypes__",
      "No async scheduler available\n\n    See http://goo.gl/MqrFmX\n",
      "[no string representation]",
      "expecting an array or an iterable object but got ",
      "cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n",
      "cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n",
      "cancellation is disabled",
      "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ",
      "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ",
      "                                                         \n                promise = ",
      ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ",
      "return function(tryCatch, errorObj, Promise) {           \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.now = 0;                                                \n            }                                                                \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    promise._pushContext();                                  \n                    var callback = this.fn;                                  \n                    var ret = tryCatch(callback)([ThePassedArguments]);      \n                    promise._popContext();                                   \n                    if (ret === errorObj) {                                  \n                        promise._rejectCallback(ret.e, false);               \n                    } else {                                                 \n                        promise._resolveCallback(ret);                       \n                    }                                                        \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise);                                      \n        ",
      "calling Promise.try with more than 1 argument",
      "you must pass at least 2 arguments to Promise.using",
      "generator .return() sentinel",
      "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n",
      "generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n",
      "cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n",
      "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ",
      "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ",
      "Input array must contain at least ",
      " items but contains only ",
      "expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n",
      "Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n",
      "ret = callback.call(this, {{args}}, nodeback); break;\n",
      "ret = callback({{args}}, nodeback); break;\n",
      "ret = callback.call(receiver, {{args}}, nodeback); break;\n",
      "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ",
      "ret = callback.apply(this, args);\n",
      "ret = callback.apply(receiver, args);\n",
      "this != null ? this['",
      "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, ",
      ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ",
      "the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n",
      "suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n",
      "BLUEBIRD_LONG_STACK_TRACES",
      "BLUEBIRD_W_FORGOTTEN_RETURN",
      "cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n",
      "cannot enable cancellation after promises are in use",
      "onCancel must be a function, got: ",
      "a promise was created in a ",
      "handler but was not returned from it",
      " is deprecated and will be removed in a future version.",
      "From previous event:",
      "    (No stack trace)",
      "Unhandled rejection "
    ],
    "0.9.5-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "A catch filter must be an error constructor",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "Circular thenable chain",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./any_promise_array.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "./settled_promise_array.js",
      "./properties_promise_array.js",
      "StopProgressPropagation",
      "./some_promise_array.js",
      "howMany must be an integer",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ],
    "0.9.6-0": [
      "./promise_resolver.js",
      "./errors_api_rejection",
      "A catch filter must be an error constructor",
      "fn must be a function",
      "Cannot enable long stack traces ",
      "after promises have been created",
      "Circular thenable chain",
      "expecting an array or a promise",
      "./synchronous_inspection.js",
      "./complex_thenables.js",
      "__BluebirdErrorTypes__",
      "\\b(?:Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|setTimeout",
      "|makeNodePromisified|processImmediate|nextTick",
      "CapturedTrace$captureStackTrace",
      "From previous event:",
      "[object PromiseResolver]",
      "./promise_inspection.js",
      "./any_promise_array.js",
      "fn is not a function",
      "generatorFunction must be a function",
      "./properties_promise_array.js",
      "var args = new Array( len + 1 );",
      "for( var i = 0; i < len; ++i ) { ",
      "   args[i] = arguments[i];",
      "( a1, a2, a3, a4, a5 ) {\"use strict\";",
      "var len = arguments.length;",
      "var resolver = Promise.pending( ",
      "var fn = nodebackForResolver( resolver );",
      "resolver.reject( maybeWrapAsError( e ) );",
      "return resolver.promise;",
      "}; ret.__isPromisified__ = true; return ret;",
      "__beforePromisified__",
      "Promise.promisify for promisifying entire objects ",
      "is deprecated. Use Promise.promisifyAll instead.",
      "callback must be a function",
      "StopProgressPropagation",
      "./some_promise_array.js",
      "howMany must be an integer",
      "./settled_promise_array.js",
      "cannot get fulfillment value of a non-fulfilled promise",
      "cannot get rejection reason of a non-rejected promise",
      "A value was yielded that could not be treated as a promise",
      "bluebird_message_key_"
    ]
  }
}